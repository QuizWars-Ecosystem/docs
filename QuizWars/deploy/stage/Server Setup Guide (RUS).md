#deploy #stage #compose #docker #rus

## Инструкция по запуску сервера

### Docker

Что бы запустить сервер на локальной машине вам обязательно понадобиться установленный Docker. Настоятельно рекомендую использовать [Docker Desktop](https://www.docker.com/products/docker-desktop/) так как он имеет удобный UI для работы.
### Make

Так же вам понадобиться установленная утилита Makefile, она позволит вам использовать уже написанные команды для работы с сервером.

Linux
```bash
sudo apt update && sudo apt install make  # Ubuntu/Debian
sudo dnf install make                     # Fedora
sudo pacman -S make                       # Arch Linux
```

macOS

```bash
xcode-select --install  # Установит make, gcc и другие инструменты
```

Windows
```bash
choco install make
```

Чтобы проверить результат установки выполните следующую команду

```bash
make --version
```

### Deployment 

Следующий шаг это скачать манифесты и конфиги сервера. Мы можете найти репозиторий с нужными нам файлами [тут](https://github.com/QuizWars-Ecosystem/deployment). Либо выполните следующие команду (рекомендуется).

```bash
git clone https://github.com/QuizWars-Ecosystem/deployment
```

Разуметься для выполнения этой команды вам потребуется установленная утилита *git*. 

Теперь у вас на локальной машине есть все что нам потребуется для полноценной работы сервера.

### Start

Что бы запустить сервер вам необходимо что бы Docker Engine был в активном состоянии. Запустите приложение Docker Desktop которое мы устанавливали ранее. 

Теперь перейдите в клонированный *deployment* репозиторий так что бы контекст вашей консоли находился в корневой папке репозитория. 

В коре репозитория вы найдете нужный нам файл *Makefile*

![[Screenshot 2025-04-21 204948.png]]

В нем вы найдете все те команды которые мы будем использовать для управлением состояния сервера. 

Тут вы можете увидеть содержание этого файла.

> [!warning] Внимание !
> На текущий момент, этот файл мог сильно измениться. Не стоит копировать команды с этого документа, возьмите их из актуального файла в репозитории.


```bash
# STAGING Docker compose commands  
stage-up:  
    make stage-gateway-up stage-users-up
  
stage-down:  
    make stage-users-down stage-gateway-down  
  
stage-gateway-up:  
    docker-compose -f ./compose/stage/api-gateway.docker-compose.yaml --env-file=./compose/stage/configs/gateway.env up -d --build  
  
stage-gateway-down:  
    docker-compose -f ./compose/stage/api-gateway.docker-compose.yaml --env-file=./compose/stage/configs/gateway.env down  
  
stage-users-up:  
    docker-compose -f ./compose/stage/users-service.docker-compose.yaml --env-file=./compose/stage/configs/users.env up -d --build  
  
stage-users-down:  
    docker-compose -f ./compose/stage/users-service.docker-compose.yaml --env-file=./compose/stage/configs/users.env down  
```

Дальше мы будем часто прибегать к командам из этого файла, так как они помогают нам сокращенно вызывать уже предопределенные команды. Давайте быстро посмотрим как их вызывать. 

Что бы взывать какую либо команду из доступных, нам просто нужно к открытой консоли написать имя утилиты *make* и псевдоним нужно нам команды.

Допустим мы хотим взывать команду *stage-up* которая уже иметься у нас в файле. Для этого просто напишите в консоли следующее.

```bash
make stage-up
```

И вы сразу увидите результат данной команды.

> [!danger] Внимание
> В рамках этого урока и и последующих действий мы будем использовать только те команды которые имеют приставку **stage-** так как именно эти команды основываются на работе в STAGE окружении. Вы можете получить нежелательный результат вызвал другие команды.
> 

### Commands

Далее мы быстро рассмотрим как запустить в локальном окружении все нужные нам программы используя все знания выше. 

Рекомендую выполнять все последующие команды прямо в консоли. Если вы будете использовать инструменты IDE для запуска этих команд, их поведение и результат может отличаться.

##### Stage commands

- **stage-up** - это команда нацелена на то что бы запустим [[API-Gateway (RUS)]] и все сервисы и их дополнительные службы одним махом. В результате вы получите полностью готовый и рабочий сервер который готов принимать ваши запросы.
- **stage-down** - это команда делает все наоборот относительно прошлой. Она остановит весь сервер в корректном порядке.
- **stage-gateway-up** - команда запустит программу проксирования  запросов и так же запустит необходимый ей компонент *Consul*.
- **stage-gateway-down** - команда вежливо остановит все входящие запросы на сервер и прекратит работу.
- **stage-{SERVICE_NAME}-up/down** - команды которые входят в этот паттерн нацелены запуск и остановку сервиса который указан в самой команде. Учтите что некоторые сервисы могут запускаться или останавливаться дальше чем другие так как они могут иметь выполняемую работу либо требуют дополнительных служб, таких как база данных.

> [!danger] Внимание !
> Каждый сервис из предоставленных должен принимать запросы непосредственно через [[API-Gateway (RUS)]]. По этому всегда удостоверяйтесь что эта программа у вас запущенна и корректно передает запросы на сервисы.  

### Manifests 

Манифесты docker-compose это файлы которые описывают в себе контейнер или группу контейнеров которые можно будет запустить непосредственно в докере с помощью команды *docker-compose*. Мы не исключение и по этому для работы в локальном окружении мы будет использовать тот же подход. 

В нашем репозитории в папке *compose/stage* (сейчас вы видите на скриншоте) 
![[Screenshot 2025-04-21 212317.png]]

Вы найдете все то что мы будем использовать. А именно сами *docker-compose* манифесты и конфиги для конфигурации программ. Как раз эти манифесты применяются в описанном нами *Makefile*. 

Давайте откроем один из них и посмотрим на его содержание. 

Выбор пал на *users-service.docker-compose.yaml*. Мы не будем вдаваться во все тонкости написания такого файла а разберем только нужные нам части.

> [!warning] Внимание !
> Все что вы увидите и прочтете дальше может уже отличаться от актуального файла.

#### Users-Servcie

> [!note] Заметка
> Заметьте что *yaml* формат файлов это ключ : значение  формат. Так же важно понимать что этот формат очень чувствителен к отступам. Что бы избежать ошибок рекомендуем не редактировать ничего пока вы не освоитесь с данным форматом. Так же рекомендую установить плагин который будет подсвечивать вам потенциальные ошибки написанного манифеста.
> 

![[Screenshot 2025-04-21 2134.png]]

Давайте разберем этот кусок лучше. 

1. *services:* - это директива которая объявляет что дальше идет список контейнеров данного манифеста.  
2. *users-service:* - это имя контейнера в данном файле, важно понимать что если вы не укажете директиву *container-name:* специально, тогда во время запуска контейнера, docker выдаст ему автоматический суффикс. Обычно это просто цифра. Пример: *users-service-1*.
3. *image:* - это она из самых основных директив контейнера. Ока содержит имя репозитория из которого docker будет брать готовый, собранный образ вашей программы если такого нет на локальной машине. В нашем случаем это образ который храниться в docker registry. После названия вы можете увидеть тег, в нашем случае это тег *latest* что говорит что мы используем самую последнюю версию образа.   
4. *volumes:* - это директива манифеста позволяет нам прокидывать внутрь контейнера файлы иди папки. Здесь мы передаем внутрь контейнера файл конфигураций нашей программы что бы она могла внутри его прочитать.
5. *networks:* - перечисляет все **внутренние** сети которые позволяют взаимодействовать контейнерам внутри docker просто через их имена и порты.
6. *depends_on:* - ставит наш контейнер в зависимость от другого по определенному условию. В нашем случае docker запускает нашу программу только когда *users-postgres* контейнер запустился и объявил о том что готов принимать соединения.  

На следующем кадры мы рассмотрим те директивы коты мы еще не видели.

![[Screenshot 2025-04-21 2153.png]]

1. *environment:* - позволяет нам назначать уже предопределенным переменным окружения свои значения. В нашем случаем на переназначаем свои переменные для *POSTGRES_USER*, *POSTGRES_PASSWORD* и *POSTGRES_DB*. 

> [!warning] Переменные окружения и их применение
> Как я уже сказал, практически все что мы используем требует конфигурации. И в *stage* окружении мы используем два подхода. Это *env* файлы и *yaml*, иногда можно встретить и другие форматы но это редко. 
> 
> Как именно это работает ?
> 
> В этой же папке вы можете найти папку *configs* она содержит в себе файлы с переменными. Сейчас мы рассмотрим самый простой и самый нужным нам формат.
> 
> Такие файлы заканчиваться на *.env*   
> 
> *Содержимое users.env*
> 
> ```env
> # Service configs  
GRPC_PORT: 21001    
USERS_DB_USERNAME: user  
USERS_DB_PASSWORD: pass  
USERS_DB_NAME: users  
USERS_DB_PORT: 15432
> ```
> 
> тут мы можем найти те же имена переменных что и в манифесте. Эти переменные содержат в себе значения которые мы задаем. Что бы передать эти переменные в контекст манифеста мы используем следующий подход.
> 
> ```bash
> docker-compose ... --env-file=./compose/stage/configs/gateway.env ...
> ```
> 
> Флаг *--env-file=...* позволяет нам прокидывать файл переменных прямо в манифест который будет выполняться docker. 
> 
> Вы можете попробовать изменить некоторые переменные и перезапустить манифест. Попробуйте изменить порт программы и тогда вы без ошибок увидите результат изменения. 

2. *restart:* - директива которая позволяет нам описать условия при которых docker сам перезапустит наше контейнер. В нашем случае он сделает это если *users-postgres* контейнер упадет с ошибкой.
3. *ports:* - директива которая описывает список портов контейнера. Важно понимать что если вы такой директивы не видите значит  что вы не сможете извне обращаться к вашей программе которая находиться в контейнере. Это могут делать только другие участники, контейнеры которые находиться *в этой же сети*. Если же вы хотите иметь возможность делать запросы на контейнер то прокиньте порт наружу. Так же учтите что важен синтаксис.  Запись 8080:8080 значит что docker будет пересылать все запросы вашей машины на порт контейнера 8080 а тот уже в свою очередь на программу внутри которая тоже находиться на порту 8080. То есть  ваша программа должна слушать внутри данный порт.
   
Что же на этом мы можем закончить урок по запуску сервера на локальной машине и основам docker-compose манифестов.
