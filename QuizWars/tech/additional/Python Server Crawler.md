#server #python #api #questions 

Основная задача сервера это работать с доступными и открытыми API содержащие готовые викторины и вопросы на различные темы. Язык сервера это Python. Сервер будет обращаться к API напрямую либо парсить контент сайтов и брать нужные данные.

Сервер должен уметь работать автоматические в своем собственном пространстве. Он не будет находиться в EKS периметре, в периметре основного сервера для безопасности. А будет иметь свое собственное пространство.
## Основные функции 

Главная задача это работать со списком API которые предоставляют вопросы. Сервер будет обращаться с каждом элементом из списка, зная его фильтры и особенности запроса и обработки. Так как это будет происходить для несколько API асинхронно, сервер должен уметь делать это по таймеру или по CRON операции (рекомендуется реализовать оба варианта). После того как сервер получил свой список запрашиваемых запросов, необходимо их обработать и поместить в базу данных с "сырым" флагом что бы в дальнейшем администрация могла вручную модерировать данные. Желательно реализовать отборочный механизм который будет уметь обрабатывать/подготавливать данные вне зависимости от источника их получения. И только те из вопросов которые возможно нуждаться в ручной модерации должны оставаться в необходимым флагом. 

Будет хорошим тоном если админ сможет контролировать конфигурации таймера или CRON операции. Это можно сделать через специальный HTTP endpoint который позволит назначать уже имеющим задачам разные значения. 

### Jobs Endpoints 

> [!warning] Внимание !
> Для каждого из следующих HTTP роутов необходимо добавить авторизацию пользователя для его действий. Все что должен делать сервер это уметь брать JWT токен из заголовков запросов и имея у себя секрет для расшифровки тела токена, проверять его права, является ли роль пользователя валидной либо де нет. 

##### Запрос на получение всех задач сервера.

```http
GET /jobs
```

Запрос должке вернуть все существующие задачи сервера которые находиться в любом из режимов. Ответом может быть следующие данные.

```json
jobs: [
{
	name: "web-site",
	url: "website.com",
	state: "WORKING" | "PAUSED" | "STOPED",
	mode: "CRON" | "TIMER",
	schedule: "*/5 * * * *",  // if CRON
	interval: 5000,          // if TIMER (millisecond),
	nextRunAt: 2025-04-29T14:30:00Z,
	lastRunAt: 2025-04-28T14:30:00Z,
},
...
]
```

---
##### Запрос на изменение режима существующей задачи и присвоение ей новой конфигурации.

```http
PUT /jobs/{jobId}/mode
```

Body Example:
```json
{
  mode: "CRON" | "TIMER",
  schedule: "*/5 * * * *",  // if CRON
  interval: 5000,           // if TIMER (millisecond)
}
```

---
##### Изменение параметров существующей задачи (CRON/TIMER)

Запрос на изменение только настроек выполнения уже существующей задачи. 

```http
PUT /jobs/{jobId}/settings
```

Body (гибкий формат, зависит от режима):

```json
{
  schedule: "*/10 * * * *",  // for CRON
  interval: 60000,         // for TIMER
}
```

---
##### Управление состоянием задачи (старт/пауза/остановка)

Запрос с возможностью останавливать, перезапускать либо ставить на паузу существующие задачи.

```http
PUT /jobs/{jobId}/state
```

Возможное тело запроса:

```json
{
	action: "START" | "PAUSE" | "STOP",
	startAt: 2025-04-28T14:30:00Z // if PAUSE
}
```

- *START* - позволяет запустить остановленную работу.
- *PAUSE* - позволяет поставить на паузу активную работу, опционально можно указать время когда заново запустить работу после паузы, если значение не указано то просто ставить задачу на паузу.
- *STOP* - позволяет полностью остановить активную работу.

### Questions

Так как мы разобрались с основными задачами данного сервера, мы может перейти не посредственно к использованию его работы. А именно то как нам работать с уже собранными вопросами. Все вопросы будут храниться в базе данных, она будет хранить только те вопросы которые еще **НЕ БЫЛИ УСПЕШНО ОТПРАЛВЕНЫ** на сервер. То есть после каждой успешной отправки, сервер может с чистой душой удалять все данные вопросов и их возможные ответы оставляя **ТОЛЬКО ХЕШ** текста вопроса что бы в будущем избежать повторений одних и тех же вопросов.

Сама передача будет происходить следующий образом. Будет некая CRON операция с дополнительным условием по количеству готовых данных. То есть у нас есть операция по отправки которая будет срабатывать каждые 6 часов (к примеру), но если сервер уже собрал более 200 готовых вопросов мы может отправить эти данные раньше плана и сбросить время нашей CRON операции. 

Логика общения между серверами следующая:

1. Python сервер выполнив условия для отправки (время/количество) будет брать сразу batch вопросов (допустим 5 штук) отправлять на сервер на определённый endpoint. 
2. Запрос будет разрешен только если Python сервер будет иметь специальный ключ, если такого нет либо он будет не валидный, запрос будет отклонен.
3. После каждого успешно отправленного запроса, Python сервер должен декрементировать счетчик вопросов на количество отправленных вопросов и так же удалить уже не нужные записи из своей базы данных.

### Configurations

Отдельно стоит сказать про конфигурацию. Так как данный сервер будет запущен в 2EC пространстве  будет очень хорошо если сервер будет уметь конфигурацию для работы не из *ENV* файла а из *YAML*, так буде значительнее безопаснее и комфортнее в работе.